{
  "name": "@webcomponents/custom-elements",
  "version": "1.0.0-rc.3",
  "description": "HTML Custom Elements Polyfill",
  "main": "custom-elements.min.js",
  "directories": {
    "test": "tests"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/webcomponents/custom-elements.git"
  },
  "author": {
    "name": "The Polymer Authors"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/webcomponents/custom-elements/issues"
  },
  "scripts": {
    "bower-install": "$(npm bin)/bower install",
    "build": "$(npm bin)/gulp",
    "test": "$(npm bin)/wct"
  },
  "homepage": "http://webcomponents.org",
  "devDependencies": {
    "bower": "^1.8.0",
    "google-closure-compiler": "^20170124.0.0",
    "gulp": "^3.8.8",
    "gulp-sourcemaps": "^1.6.0",
    "rollup-stream": "^1.14.0",
    "vinyl-source-stream": "^1.1.0",
    "web-component-tester": "^6.0.0-prerelease.3"
  },
  "gitHead": "bf2f0a4aee940223cfa7eb18e29bd1da51edb90f",
  "readme": "# Custom Elements (v1) Polyfill [![Build Status](https://travis-ci.org/webcomponents/custom-elements.svg?branch=master)](https://travis-ci.org/webcomponents/custom-elements)\n\nA polyfill for the [custom elements](https://html.spec.whatwg.org/multipage/scripting.html#custom-elements)\nv1 spec.\n\n## Using\n\nInclude `custom-elements.min.js` at the beginning of your page, *before* any code that\nmanipulates the DOM:\n```html\n<script src=\"custom-elements.min.js\"></script>\n```\n\n## Developing\n\n1. Install and build\n\n  ```\n  npm install\n  npm run build\n  ```\n  (Or, `npm i && gulp`, if [gulp](https://github.com/gulpjs/gulp) is installed globally.)\n\n1. Test\n\n  ```\n  npm run test\n  ```\n  (Or, [`wct`](https://github.com/Polymer/web-component-tester), if installed\n  globally.)\n\n## Custom element reactions in the DOM and HTML specs\n\nAPI which might trigger custom element reactions in the [DOM](https://dom.spec.whatwg.org/)\nand [HTML](https://html.spec.whatwg.org/) specifications are marked with the\n[`CEReactions` extended attribute](https://html.spec.whatwg.org/multipage/scripting.html#cereactions).\n\n## Known Bugs and Limitations\n\n- `adoptedCallback` is not supported.\n- Changing an attribute of a customizable (but uncustomized) element will not\n  cause that element to upgrade.\n- Only DOM API is patched. Notably, this excludes API from the HTML spec marked\n  with the `CEReactions` extended attribute.\n  - Unpatched API from the DOM spec:\n    - Setters on `Element` for `id`, `className`, and `slot`.\n    - `DOMTokenList` (`element.classList`)\n    - `NamedNodeMap` (`element.attributes`)\n    - `Attr` (`element.attributes.getNamedItem('attr-name')`)\n- The [custom element reactions stack](https://html.spec.whatwg.org/multipage/scripting.html#custom-element-reactions-stack)\n  is not implemented.\n  - Typically, DOM operations patched in this polyfill gather the list of\n    elements to which a given callback would apply and then iterate that list,\n    calling the callback on each element. This mechanism breaks down if an\n    element's callback performs another DOM operation that manipulates an area\n    of the tree that was captured in the outer operation's list of elements.\n    When this happens, the callbacks from the inner DOM operation will be called\n    *before* those of the outer DOM operation (typically, depending on the patch\n    implementation), as opposed to a spec-compliant implementation where the\n    callbacks are always run in the order they were inserted into each\n    particular element's reaction queue.\n- Custom elements created by the UA's parser are customized as if they were\n  upgraded, rather than constructed.\n  - These elements are only learned about *after* they have been constructed,\n    and typically after their descendants have been constructed. When these\n    elements are constructed, their children are visible and editable *even\n    though they would not yet exist and manipulating them would throw in a\n    spec-compliant implementation of custom elements!*\n- The [requirements for custom element constructors](https://html.spec.whatwg.org/multipage/scripting.html#custom-element-conformance)\n  are not enforced.\n  - These requirements are not generally enforcable in user script because of\n    the ability to use the `new` operator on a custom element constructor. This\n    means there is no way to know when a call to a constructor has begun or\n    finished.\n- Methods of the `ParentNode` and `ChildNode` interfaces do not support\n  `DocumentFragment`s as arguments.\n- Your custom element constructor's prototype *must* have a property named\n  `constructor` which is that constructor.\n  - By default, for every constructable function `F`, `F.prototype.constructor === F`.\n    If you replace the prototype of your constructor `F`, you must make sure\n    that `F.prototype.constructor === F` remains true. Otherwise, the polyfill\n    will not be able to create or upgrade your custom elements.\n\n### ES5 vs ES2015\n\nThe custom elements v1 spec is not compatible with ES5 style classes. This means\nES2015 code compiled to ES5 will not work with a native implementation of Custom\nElements.[0] While it's possible to force the custom elements polyfill to be\nused to workaround this issue (by setting (`customElements.forcePolyfill = true;`\nbefore loading the polyfill), you will not be using the UA's native\nimplementation in that case.\n\nSince this is not ideal, we've provided an alternative:\n[native-shim.js](https://github.com/webcomponents/custom-elements/blob/master/src/native-shim.js).\nLoading this shim minimally augments the native implementation to be compatible\nwith ES5 code. We are also working on some future refinements to this approach\nthat will improve the implementation and automatically detect if it's needed.\n\n[0] The spec requires that an element call the `HTMLElement` constructor.\nTypically an ES5 style class would do something like `HTMLElement.call(this)` to\nemulate `super()`. However, `HTMLElement` *must* be called as a constructor and\nnot as a plain function, i.e. with `Reflect.construct(HTMLElement, [], MyCEConstructor)`,\nor it will throw.\n\n### Parser-created elements in the main document\n\nBy default, the polyfill uses a `MutationObserver` to learn about and upgrade\nelements in the main document as they are parsed. This `MutationObserver` is\nattached to `document` synchronously when the script is run.\n- If you attach a `MutationObserver` earlier before loading the polyfill, that\n  mutation observer will not see upgraded custom elements.\n- If you move a node with descendants that have not yet been inserted by the\n  parser out of the main document, those nodes will not be noticed or upgraded\n  (until another action would trigger an upgrade).\n\nNote: Using `polyfillWrapFlushCallback` disconnects this `MutationObserver`.\n\n### `customElements.polyfillWrapFlushCallback`\n\ntl;dr: The polyfill gets slower as the size of your page and number of custom\nelement definitons increases. You can use `polyfillWrapFlushCallback` to prevent\nredundant work.\n\nTo avoid a potential memory leak, the polyfill does not maintain a list of upgrade\ncandidates. This means that calling `customElements.define` causes a synchronous,\nfull-document walk to search for elements with `localName`s matching the new\ndefinition. Given that this operation is potentially expensive and, if your page\nloads many custom element definitions before using any of them, highly redundant,\nan extra method is added to the `CustomElementRegistry` prototype -\n`polyfillWrapFlushCallback`.\n\n`polyfillWrapFlushCallback` allows you to block the synchronous, full-document\nupgrade attempts made when calling `define` and perform them later. Call\n`polyfillWrapFlushCallback` with a function; the next time `customElements.define`\nis called and a full-document upgrade would happen, your function will be called\ninstead. The only argument to your function is *another* function which, when\ncalled, will run the full-document upgrade attempt.\n\nFor example, if you wanted to delay upgrades until the document's ready state\nwas `'complete'`, you could use the following:\n\n```javascript\ncustomElements.polyfillWrapFlushCallback(function(flush) {\n  if (document.readyState === 'complete') {\n    // If the document is already complete, flush synchronously.\n    flush();\n  } else {\n    // Otherwise, wait until it is complete.\n    document.addEventListener('readystatechange', function() {\n      if (document.readyState === 'complete') {\n        flush();\n      }\n    });\n  }\n});\n```\n\nOnce your wrapper function is called (because the polyfill wants to upgrade the\ndocument), it will not be called again until you have triggered the\nfull-document upgrade attempt. If multiple definitions are registered before you\ntrigger upgrades, all of those definitions will apply when you trigger upgrades -\ndon't call the provided function multiple times.\n\nPromises returned by `customElements.whenDefined` will not resolve until a\nfull-document upgrade attempt has been performed *after* the given local name\nhas been defined.\n\n```javascript\nlet flush;\ncustomElements.polyfillWrapFlushCallback(f => flush = f);\n\nconst p = customElements.whenDefined('c-e', () => console.log('c-e defined'));\n\ncustomElements.define('c-e', class extends HTMLElement {});\n// `p` is not yet resolved; `flush` is now a function.\n\nflush(); // Resolves `p`.\n```\n\nYou can't remove a callback given to `polyfillWrapFlushCallback`. If the\ncondition your callback was intended to wait on is no longer important, your\ncallback should call the given function synchronously. (See the\n`document.readyState` example above.)\n\n**Calling `polyfillWrapFlushCallback` disconnects the `MutationObserver` watching\nthe main document.** This means that you must delay until at least\n`document.readyState !== 'loading'` to be sure that all elements in the main\ndocument are found (subject to exceptions mentioned in the section above).\n\nYou can call `polyfillWrapFlushCallback` multiple times, each function given\nwill automatically wrap and delay any previous wrappers:\n\n```javascript\ncustomElements.polyfillWrapFlushCallback(function(flush) {\n  console.log('added first');\n  flush();\n});\n\ncustomElements.polyfillWrapFlushCallback(function(flush) {\n  console.log('added second');\n  setTimeout(() => flush(), 1000);\n});\n\ncustomElements.define('c-e', class extends HTMLElement {});\n// 'added second'\n// ~1s delay\n// 'added first'\n// The document is walked to attempt upgrades.\n```\n",
  "readmeFilename": "README.md",
  "_id": "@webcomponents/custom-elements@1.0.0-rc.3",
  "_shasum": "04bf9d75414d39cd2d2a696d0a96b083cd4cf008",
  "_from": "onsenui/custom-elements#1.0.0-rc.3+mod.20170410.1",
  "_resolved": "git://github.com/onsenui/custom-elements.git#bf2f0a4aee940223cfa7eb18e29bd1da51edb90f"
}
